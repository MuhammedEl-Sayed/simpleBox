/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { forwardRef, useRef, useEffect } from "react";
import { useFrame, useThree, instancedMesh } from "@react-three/fiber";
import * as THREE from "three";
import { useGesture } from "react-use-gesture";
import {useCompoundBody } from "@react-three/cannon";

const tempObject = new THREE.Object3D();

export const SimpleBox = forwardRef((props, passedRef) => {
  const { size, viewport } = useThree();
  const aspect = size.width / viewport.width;

  const [ref, api] = useCompoundBody(() => ({
    mass: props.mass,
    ...props,
    position: props.positionInScreen,
    rotation: props.rotationInScreen,
    shapes: props.colliders,
  }));

  const position = useRef([0, 0, 0]);
  const rot = useRef([0, 0, 0]);

  useEffect(() => {
    const unsubscribe = api.position.subscribe((v) => (position.current = v));
    return unsubscribe;
  }, []);

  useEffect(() => {
    const unsubscribe = api.rotation.subscribe((v) => (rot.current = v));
    return unsubscribe;
  }, []);

  let [currentPosx, currentPosy] = [0, 0];
  
  const bind = useGesture({
    onDrag: ({ movement: [x, y], first: intial}) => {

      if (intial) {
        currentPosx = position.current[0];
        currentPosy = position.current[1];
      }
      copyX = ((x - position.current[0]) / aspect) * 1.2 + currentPosx;
      copyY = ((position.current[1] - y) / aspect) * 1.2 + currentPosy;
      api.mass.set(0);

      api.position.set(
        ((x - position.current[0]) / aspect) * 1.2 + currentPosx,
        ((position.current[1] - y) / aspect) * 1.2 + currentPosy,
        0
      );

    },

    onPointerUp: ({}) => {
      api.mass.set(1);
      api.wakeUp(false);
    },
  });

  var count = props.colliders.length;
  const mesh = useRef();
  useFrame(() => {
    passedRef.current.position.x = position.current[0];
    passedRef.current.position.y = position.current[1];
    passedRef.current.position.z = position.current[2];
    passedRef.current.rotation.x = rot.current[0];
    passedRef.current.rotation.y = rot.current[1];
    passedRef.current.rotation.z = rot.current[2];
    let i = 0;
    for (let x = 0; x < count; x++) {
      const id = i++;
      tempObject.position.set(props.colliders[x].position[0]+passedRef.current.position.x  , props.colliders[x].position[1]+ passedRef.current.position.y,props.colliders[x].position[2]+ passedRef.current.position.z);
      tempObject.rotation.set(passedRef.current.rotation.x  , passedRef.current.rotation.y,passedRef.current.rotation.z);
      tempObject.scale.set(props.colliders[x].args[0], props.colliders[x].args[1],props.colliders[x].args[2])
      
      tempObject.updateMatrix();
      mesh.current.setMatrixAt(id, tempObject.matrix);

      mesh.current.instanceMatrix.needsUpdate = true;
    }
  });






  return (
    <>
      <group>
        <group ref={passedRef} {...props}dispose={null}></group>
      </group>
      <instancedMesh ref={mesh}  {...bind()} args={[null, null, count]}>
        <boxBufferGeometry attach="geometry">
        </boxBufferGeometry>
          <meshStandardMaterial transparent={true} opacity={0} attach="material"/>
      </instancedMesh>
     
    </>
  );
});
